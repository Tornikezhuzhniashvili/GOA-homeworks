<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <h1 id="nav">Navigation</h1>
    <hr />
    <nav>
      <ul>
        <li>
          <a href="#WebAssembly"><button>Go to WebAssembly</button></a>
          <a href="#history"><button>Go to History</button></a>
          <a href="#implementations"><button>Go to Implementations</button></a>
          <a href="#compilers"><button>Go to Compilers</button></a>
          <a href="#limitations"><button>Go to Limitations</button></a>
          <a href="#securityconsiderations"
            ><button>Go to Security Considerations</button></a
          >
          <a href="#wasi"><button>Go to WASI</button></a>
          <a href="#specification"><button>Go to specification</button></a>
        </li>
      </ul>
    </nav>
    <br />

    <center>
      <h1 id="WebAssembly">WebAssembly</h1>
    </center>
    <p>
      WebAssembly (Wasm) defines a portable binary-code format and a
      corresponding text format for executable programs as well as software
      interfaces for facilitating communication between such programs and their
      host environment. The main goal of WebAssembly is to facilitate
      high-performance applications on web pages, but it is also designed to be
      usable in non-web environments. It is an open standard intended to support
      any language on any operating system, and in practice many of the most
      popular languages already have at least some level of support. Announced
      in 2015 and first released in March 2017, WebAssembly became a World Wide
      Web Consortium recommendation on 5 December 2019 and it received the
      Programming Languages Software Award from ACM SIGPLAN in 2021. The World
      Wide Web Consortium (W3C) maintains the standard with contributions from
      Mozilla, Microsoft, Google, Apple, Fastly, Intel, and Red Hat
    </p>
    <img
      src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1f/WebAssembly_Logo.svg/1024px-WebAssembly_Logo.svg.png"
      alt="webassem"
      width="295px"
    />
    <center>
      <a href="#nav">Go Back To Navigations</a>
    </center>
    <hr />
    <h2 id="history">History</h2>
    <p>
      The name WebAssembly is intended to seem synonymous with that of the
      assembly language. The name suggests bringing assembly-like programming to
      the Web, where it will be executed client-side — by the website-user's
      computer via the user's web browser. To accomplish this, WebAssembly must
      be much more hardware-independent than a true assembly language.
      WebAssembly was first announced in 2015, and the first demonstration was
      executing Unity's Angry Bots in Firefox, Google Chrome, and Microsoft
      Edge.The precursor technologies were asm.js from Mozilla and Google Native
      Client, and the initial implementation was based on the feature set of
      asm.js. The asm.js file already provides near-native code execution speeds
      and can be considered a viable alternative for browsers that do not
      support WebAssembly or have it disabled for security reasons. In March
      2017, the design of the minimum viable product (MVP) was declared to be
      finished and the preview phase ended. In late September 2017, Safari 11
      was released with support. In February 2018, the WebAssembly Working Group
      published three public working drafts for the Core Specification,
      JavaScript Interface, and Web API. In June 2019, Chrome 75 was released
      with WebAssembly threads enabled by default. Since April 2022, WebAssembly
      2.0 was in draft status, which added many SIMD-related instructions and a
      new v128 datatype, with the ability for functions to return multiple
      values, and mass memory initialize/copy.
    </p>
    <img
      src="https://www.researchgate.net/publication/373229823/figure/fig1/AS:11431281182677640@1692504571675/WebAssembly-data-flow-architecture.ppm"
      a="architecture"
      width="400px"
    />
    <center>
      <a href="#nav">Go Back To Navigations</a>
    </center>
    <hr />
    <h2 id="implementations">Implementations</h2>
    <p>
      While WebAssembly was initially designed to permit near-native code
      execution speed in the web browser, it has been considered valuable
      outside of such, in more generalized contexts. Since WebAssembly's runtime
      environments (RE) are low-level virtual stack machines (akin to JVM or
      Flash VM) that may be embedded into host applications, some
      implementations create standalone runtime environments like Wasmtime
      [Wikidata] and Wasmer [Wikidata]. WebAssembly runtime environments are
      embedded in application servers to host "server-side" WebAssembly
      applications and in other applications to support plug-in-based software
      extension architectures, e.g., "WebAssembly for Proxies" (proxy-wasm)
      which specifies a WebAssembly-based ABI for extending proxy servers.
    </p>
    <h3>Web browsers</h3>
    <p>
      In November 2017, Mozilla declared support "in all major browsers", after
      WebAssembly was enabled by default in Edge 16. This support also includes
      mobile web browsers for iOS and Android. As of March 2024, 99% of tracked
      web browsers support WebAssembly (version 1.0), more than for its
      predecessor asm.js. For some extensions, from the 2.0 draft standard,
      support may be lower, but still more than 90% of web browsers may already
      support, e.g. for reference types extension.
    </p>
    <img
      src="https://www.interlogica.it/wp-content/uploads/2018/11/infografica-Web-Assembly-eng.jpg"
      alt="how does webassembly work"
      width="380px"
    />
    <center>
      <a href="#nav">Go Back To Navigations</a>
    </center>
    <hr />
    <h2 id="compilers">Compilers</h2>
    <p>
      WebAssembly implementations usually use either ahead-of-time (AOT) or
      just-in-time (JIT) compilation, but may also use an interpreter. While the
      first implementations have landed in web browsers, there are also
      non-browser implementations for general-purpose use, including
      Wasmer,Wasmtime or WAMR, wasm3, WAVM, and many others. Because WebAssembly
      executables are precompiled, it is possible to use a variety of
      programming languages to make them. This is achieved either through direct
      compilation to Wasm, or through an implementation of their corresponding
      virtual machines in Wasm. Some 40 programming languages are reported to
      support Wasm as a compilation target. Emscripten compiles C and C++ to
      Wasm using the Binaryen and LLVM as backend. The Emscripten SDK can
      compile any LLVM-supported languages (such as C, C++ or Rust, among
      others) source code into a binary file which runs in the same sandbox as
      JavaScript code.[note 1] Emscripten provides bindings for several commonly
      used environment interfaces like WebGL. As of version 8, a standalone
      Clang can compile C and C++ to Wasm. Its initial aim was to support
      compilation from C and C++, though support for other source languages such
      as Rust, .NET languages and AssemblyScript (TypeScript-like) is also
      emerging. After the MVP release, WebAssembly added support for
      multithreading and garbage collection, which allowed more efficient
      compilation for garbage-collecting programming languages like C#
      (supported via Blazor), F# (supported via Bolero with help of Blazor) and
      Python. A number of other languages have some support, including Python,
      Julia, Ruby and Ring. A number of systems can compile Java and other JVM
      languages to JavaScript and WebAssembly. These include CheerpJ,
      JWebAssembly and TeaVM. Kotlin supports WebAssembly directly.
    </p>
    <img
      src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR7PD6D1urZBkP_kk8VV8o4McjFtwGCurGszg&s"
      alt="introduction to webassembly"
      width="377px"
    />
    <center>
      <a href="#nav">Go Back To Navigations</a>
    </center>
    <hr />
    <h2 id="limitations">Limitations</h2>
    <p>
      Web browsers do not permit WebAssembly code to directly manipulate the
      Document Object Model. Wasm code must defer to JavaScript for this.[note
      2] In an October 2023 survey of developers, less than half of the 303
      participants were satisfied with the state of WebAssembly. A large
      majority cited the need for improvement in four areas: WASI, debugging
      support, integration with JavaScript and browser APIs, and build tooling.
      For memory-intensive allocations in WebAssembly, there are "grave
      limitations that make many applications infeasible to be reliably deployed
      on mobile browsers Currently allocating more than ~300MB of memory is not
      reliable on Chrome on Android without resorting to Chrome-specific
      workarounds, nor in Safari on iOS." All major browsers allow WebAssembly
      if Content-Security-Policy is not specified, or if "unsafe-eval" is used,
      but behave differently otherwise. Chrome requires "unsafe-eval", though a
      worker thread can be a workaround.
    </p>
    <img
      src="https://www.secondstate.io/articles/why-webassembly-server-01.png"
      alt=""
      width="373px"
    />
    <center>
      <a href="#nav">Go Back To Navigations</a>
    </center>
    <hr />
    <h2 id="securityconsiderations">Security Considerations</h2>
    <p>
      In June 2018, a security researcher presented the possibility of using
      WebAssembly to circumvent browser mitigations for Spectre and Meltdown
      security vulnerabilities once support for threads with shared memory is
      added. Due to this concern, WebAssembly developers put the feature on
      hold.However, in order to explore these future language extensions, Google
      Chrome added experimental support for the WebAssembly thread proposal in
      October 2018. WebAssembly has been criticized for allowing greater ease of
      hiding the evidence for malware writers, scammers and phishing attackers;
      WebAssembly is present on the user's machine only in its compiled form,
      which "[makes malware] detection difficult". Speed and the easy ability to
      conceal in WebAssembly have led to its use in hidden crypto mining within
      the website visitor's device. Coinhive, a now defunct service facilitating
      cryptocurrency mining in website visitors' browsers, claims their "miner
      uses WebAssembly and runs with about 65% of the performance of a native
      Miner."[79] A June 2019 study from the Technische Universität Braunschweig
      analyzed the usage of WebAssembly in the Alexa top 1 million websites and
      found the prevalent use was for malicious crypto mining, and that malware
      accounted for more than half of the WebAssembly-using websites studied. An
      April 2021 study from Universität Stuttgart found that since then crypto
      mining has been marginalized, falling to below 1% of all WebAssembly
      modules gathered from a wide range of sources, also including the Alexa
      top 1 million websites. As WebAssembly supports only structured control
      flow, it is amenable toward security verification techniques including
      symbolic execution.
    </p>
    <img
      src="https://wasmer.io/images/blog/wasm-universal-binary.png"
      alt=""
      width="393px"
    />
    <center>
      <a href="#nav">Go Back To Navigations</a>
    </center>
    <hr />
    <h2 id="wasi">WASI</h2>
    <p>
      WebAssembly System Interface (WASI) is a simple interface (ABI and API)
      designed by Mozilla intended to be portable to any platform. It provides
      POSIX-like features like file I/O constrained by capability-based
      security.There are additional proposed ABI/APIs. WASI is influenced by
      CloudABI and Capsicum.[according to whom?] Solomon Hykes, a co-founder of
      Docker, wrote in 2019, "If WASM+WASI existed in 2008, we wouldn't have
      needed to create Docker. That's how important it is. WebAssembly on the
      server is the future of computing.
    </p>
    <img
      src="https://regmedia.co.uk/2020/01/16/wasm-explorer.png"
      alt=""
      width="395px"
    />
    <center>
      <a href="#nav">Go Back To Navigations</a>
    </center>
    <hr />
    <h2 id="specification">Specification</h2>
    <h3>Host environment</h3>
    <p>
      The general standard provides core specifications for the JavaScript API
      and details on embedding.
    </p>
    <h3>Virtual machine</h3>
    <p>
      Wasm code (binary code, i.e. bytecode) is intended to be run on a portable
      virtual stack machine (VM). The VM is designed to be faster to parse and
      execute than JavaScript and to have compact code representation.Any
      external functionality (like syscalls) that may be expected by Wasm binary
      code is not stipulated by the standard. It rather provides a way to
      deliver interfacing via modules by the host environment that the VM runs
      in.
    </p>
    <h3>Wasm program</h3>
    <p>
      A Wasm program is designed as a separate module containing collections of
      various Wasm-defined values and program type definitions. These are
      provided in either binary or textual format (see below) that have a common
      structure. Such a module may provide a start function that is executed
      upon instantiation of a wasm binary.
    </p>
    <h4>Instruction set</h4>
    <p>
      The core standard for the binary format of a Wasm program defines an
      instruction set architecture (ISA) consisting of specific binary encodings
      of types of operations which are executed by the VM (without specifying
      how exactly they must be executed).The list of instructions includes
      standard memory load/store instructions, numeric, parametric, control of
      flow instruction types and Wasm-specific variable instructions.
    </p>
    <p>
      The number of opcodes used in the original standard (MVP) was a bit fewer
      than 200 of the 256 possible opcodes. Subsequent versions of WebAssembly
      pushed the number of opcodes a bit over 200. The WebAssembly SIMD proposal
      (for parallel processing) introduces an alternate opcode prefix (0xfd) for
      128-bit SIMD. The concatenation of the SIMD prefix, plus an opcode that is
      valid after the SIMD prefix, forms a SIMD opcode. The SIMD opcodes bring
      an additional 236 instructions for the "minimum viable product" (MVP) SIMD
      capability (for a total of around 436 instructions). Those instructions,
      the "finalized opcodes" are enabled by default across Google's V8 (in
      Google Chrome), the SpiderMonkey engine in Mozilla Firefox, and the
      JavaScriptCore engine in Apple's Safari and there are also some additional
      proposal for instructions for later "post SIMD MVP", and there's also a
      separate "relaxed-simd" proposal on the table. These SIMD opcodes are also
      portable and translate to native instruction sets like x64 and ARM. In
      contrast, neither Java's JVM nor CIL support SIMD, at their opcode level,
      i.e. in the standard; both do have some parallel APIs which provide SIMD
      speedup. There is an extension for Java adding intrinsics for x64 SIMD,
      that isn't portable, i.e. not usable on ARM or smartphones. Smartphones
      can support SIMD by calling assembly code with SIMD, and C# has similar
      support.
    </p>
    <h4>Code representation</h4>
    <p>
      In March 2017, the WebAssembly Community Group reached consensus on the
      initial (MVP) binary format, JavaScript API, and reference
      interpreter.[106] It defines a WebAssembly binary format (.wasm), which is
      not designed to be used by humans, as well as a human-readable WebAssembly
      text format (.wat) that resembles a cross between S-expressions and
      traditional assembly languages. The table below shows an example of a
      factorial function written in C and its corresponding WebAssembly code
      after compilation, shown both in .wat text format (a human-readable
      textual representation of WebAssembly) and in .wasm binary format (the raw
      bytecode, expressed below in hexadecimal), that is executed by a Web
      browser or run-time environment that supports WebAssembly.
    </p>
    <img
      src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS-SL_fZiosjTVH9SfdaAqF2dG7w_Kfu-N-uA&s"
      alt=""
      width="364px"
    />
    <center>
      <a href="#nav">Go Back To Navigations</a>
    </center>

    <hr />
    <a href="../index.html"><button>Main Page</button></a>
  </body>
</html>
